#!/usr/bin/env python3
"""
TrinityCore Module Creator
A utility script to create new module templates for TrinityCore

Usage:
    python create_module.py <module_name> [options]
    
Example:
    python create_module.py MyAwesomeModule --author "John Doe" --description "An awesome module"
"""

import os
import sys
import json
import argparse
from datetime import datetime
from pathlib import Path

def create_module_structure(module_name, base_dir):
    """Create the basic directory structure for a module"""
    module_dir = base_dir / f"mod-{module_name.lower()}"
    
    if module_dir.exists():
        raise FileExistsError(f"Module directory {module_dir} already exists")
    
    # Create directories
    directories = [
        module_dir,
        module_dir / "src",
        module_dir / "conf",
        module_dir / "tests",
        module_dir / "docs",
        module_dir / "sql",
        module_dir / "data"
    ]
    
    for directory in directories:
        directory.mkdir(parents=True, exist_ok=True)
        print(f"Created directory: {directory}")
    
    return module_dir

def create_module_json(module_dir, module_name, author, description, version, core_version):
    """Create the module.json configuration file"""
    module_json = {
        "name": module_name,
        "version": version,
        "description": description,
        "author": author,
        "core_version": core_version,
        "enabled": True,
        "dependencies": [],
        "features": [
            "player_events",
            "configuration",
            "chat_commands"
        ],
        "requirements": {
            "cmake_minimum": "3.16",
            "cpp_standard": "17",
            "platforms": ["Windows", "Linux", "macOS"]
        },
        "permissions": {
            "database_access": False,
            "file_system_access": True,
            "network_access": False,
            "admin_commands": False
        },
        "configuration": {
            "config_file": f"{module_name}.conf",
            "hot_reload": True,
            "validation": True
        },
        "installation": {
            "auto_install": True,
            "requires_restart": False,
            "backup_config": True
        },
        "metadata": {
            "created": datetime.now().isoformat(),
            "license": "GPL-2.0",
            "homepage": "",
            "repository": "",
            "issues": ""
        },
        "changelog": [
            {
                "version": version,
                "date": datetime.now().strftime("%Y-%m-%d"),
                "changes": ["Initial module creation"]
            }
        ]
    }
    
    json_file = module_dir / "module.json"
    with open(json_file, 'w', encoding='utf-8') as f:
        json.dump(module_json, f, indent=2, ensure_ascii=False)
    
    print(f"Created: {json_file}")
    return json_file

def create_cmake_file(module_dir, module_name):
    """Create the CMakeLists.txt file for the module"""
    cmake_content = f'''#
# {module_name} Module CMake Configuration
# Generated by TrinityCore Module Creator
#

cmake_minimum_required(VERSION 3.16)

# Read module metadata
file(READ "${{CMAKE_CURRENT_SOURCE_DIR}}/module.json" MODULE_JSON)

# Extract module information (simplified JSON parsing)
string(REGEX MATCH "\\"name\\"[[:space:]]*:[[:space:]]*\\"([^\\"]+)\\"" MODULE_NAME_MATCH "${{MODULE_JSON}}")
if(MODULE_NAME_MATCH)
    set(MODULE_NAME "${{CMAKE_MATCH_1}}")
else()
    set(MODULE_NAME "{module_name}")
endif()

string(REGEX MATCH "\\"version\\"[[:space:]]*:[[:space:]]*\\"([^\\"]+)\\"" MODULE_VERSION_MATCH "${{MODULE_JSON}}")
if(MODULE_VERSION_MATCH)
    set(MODULE_VERSION "${{CMAKE_MATCH_1}}")
else()
    set(MODULE_VERSION "1.0.0")
endif()

message(STATUS "Configuring module: ${{MODULE_NAME}} v${{MODULE_VERSION}}")

# Module source files
file(GLOB_RECURSE MODULE_SOURCES
    "${{CMAKE_CURRENT_SOURCE_DIR}}/src/*.cpp"
    "${{CMAKE_CURRENT_SOURCE_DIR}}/src/*.h"
)

# Create module library
add_library(${{MODULE_NAME}} SHARED ${{MODULE_SOURCES}})

# Set target properties
set_target_properties(${{MODULE_NAME}} PROPERTIES
    CXX_STANDARD 17
    CXX_STANDARD_REQUIRED ON
    VERSION ${{MODULE_VERSION}}
    SOVERSION 1
    OUTPUT_NAME "${{MODULE_NAME}}"
    PREFIX "mod_"
)

# Include directories
target_include_directories(${{MODULE_NAME}} PRIVATE
    "${{CMAKE_CURRENT_SOURCE_DIR}}/src"
    "${{CMAKE_SOURCE_DIR}}/src/server/game/Plugins"
    "${{CMAKE_SOURCE_DIR}}/src/server/shared"
    "${{CMAKE_SOURCE_DIR}}/src/server/database"
    "${{CMAKE_SOURCE_DIR}}/src/common"
)

# Link against TrinityCore libraries
target_link_libraries(${{MODULE_NAME}} PRIVATE
    game
    shared
    common
)

# Compiler definitions
target_compile_definitions(${{MODULE_NAME}} PRIVATE
    MODULE_NAME="${{MODULE_NAME}}"
    MODULE_VERSION="${{MODULE_VERSION}}"
)

# Platform-specific settings
if(WIN32)
    target_compile_definitions(${{MODULE_NAME}} PRIVATE
        WIN32_LEAN_AND_MEAN
        NOMINMAX
    )
endif()

# Debug settings
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_definitions(${{MODULE_NAME}} PRIVATE
        MODULE_DEBUG=1
    )
endif()

# Installation
install(TARGETS ${{MODULE_NAME}}
    LIBRARY DESTINATION "${{CMAKE_INSTALL_LIBDIR}}/modules"
    RUNTIME DESTINATION "${{CMAKE_INSTALL_BINDIR}}/modules"
    COMPONENT modules
)

# Install configuration files
file(GLOB MODULE_CONFIGS "${{CMAKE_CURRENT_SOURCE_DIR}}/conf/*.conf")
if(MODULE_CONFIGS)
    install(FILES ${{MODULE_CONFIGS}}
        DESTINATION "${{CMAKE_INSTALL_SYSCONFDIR}}/modules"
        COMPONENT modules
    )
endif()

# Install SQL files
file(GLOB MODULE_SQL "${{CMAKE_CURRENT_SOURCE_DIR}}/sql/*.sql")
if(MODULE_SQL)
    install(FILES ${{MODULE_SQL}}
        DESTINATION "${{CMAKE_INSTALL_DATADIR}}/sql/modules/${{MODULE_NAME}}"
        COMPONENT modules
    )
endif()

# Install documentation
if(EXISTS "${{CMAKE_CURRENT_SOURCE_DIR}}/README.md")
    install(FILES "${{CMAKE_CURRENT_SOURCE_DIR}}/README.md"
        DESTINATION "${{CMAKE_INSTALL_DOCDIR}}/modules/${{MODULE_NAME}}"
        COMPONENT modules
    )
endif()

# Validation
if(NOT MODULE_SOURCES)
    message(WARNING "No source files found for module ${{MODULE_NAME}}")
endif()

# Testing
if(BUILD_TESTING)
    file(GLOB TEST_SOURCES "${{CMAKE_CURRENT_SOURCE_DIR}}/tests/*.cpp")
    if(TEST_SOURCES)
        add_executable(test_${{MODULE_NAME}} ${{TEST_SOURCES}})
        target_link_libraries(test_${{MODULE_NAME}} ${{MODULE_NAME}} gtest gtest_main)
        add_test(NAME "${{MODULE_NAME}}_tests" COMMAND test_${{MODULE_NAME}})
    endif()
endif()

# Development helpers
add_custom_target(${{MODULE_NAME}}_install
    COMMAND ${{CMAKE_COMMAND}} --build . --target install --component modules
    DEPENDS ${{MODULE_NAME}}
    COMMENT "Installing ${{MODULE_NAME}} module"
)

message(STATUS "Module ${{MODULE_NAME}} configured successfully")
'''
    
    cmake_file = module_dir / "CMakeLists.txt"
    with open(cmake_file, 'w', encoding='utf-8') as f:
        f.write(cmake_content)
    
    print(f"Created: {cmake_file}")
    return cmake_file

def create_header_file(module_dir, module_name, author):
    """Create the main module header file"""
    class_name = f"{module_name}Module"
    header_content = f'''/*
 * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef {module_name.upper()}_MODULE_H
#define {module_name.upper()}_MODULE_H

#include "IPlugin.h"
#include "PluginConfig.h"
#include <memory>
#include <unordered_map>
#include <mutex>

class Player;
class WorldSession;

/**
 * {module_name} Module
 * 
 * @author {author}
 * @version 1.0.0
 * 
 * This module provides [describe your module functionality here]
 */
class {class_name} : public IPlugin
{{
public:
    {class_name}();
    virtual ~{class_name}();
    
    // IPlugin interface
    bool Initialize() override;
    void Shutdown() override;
    void Update(uint32 diff) override;
    
    const char* GetName() const override {{ return "{module_name}"; }}
    const char* GetVersion() const override {{ return "1.0.0"; }}
    const char* GetAuthor() const override {{ return "{author}"; }}
    const char* GetDescription() const override {{ return "{module_name} module for TrinityCore"; }}
    
    PluginPriority GetPriority() const override {{ return PLUGIN_PRIORITY_NORMAL; }}
    
    bool IsEnabled() const {{ return _enabled; }}
    
    // Configuration management
    bool LoadConfiguration();
    bool ReloadConfiguration();
    
    // Event handlers
    void OnPlayerLogin(Player* player);
    void OnPlayerLogout(Player* player);
    void OnPlayerLevelChanged(Player* player, uint8 oldLevel);
    void OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg);
    
    // Chat commands
    bool HandleInfoCommand(ChatHandler* handler, char const* args);
    bool HandleConfigCommand(ChatHandler* handler, char const* args);
    
    // Singleton access
    static {class_name}* GetInstance();
    
private:
    // Configuration structure
    struct ModuleConfig
    {{
        bool enabled = true;
        bool debugMode = false;
        
        // Add your configuration options here
        std::string welcomeMessage = "Welcome to the server!";
        bool enableWelcome = true;
        uint32 welcomeDelay = 5;
        
        // Feature flags
        bool enablePlayerTracking = true;
        bool enableChatLogging = false;
        bool enableStatistics = true;
    }};
    
    // Player data structure
    struct PlayerData
    {{
        uint32 loginCount = 0;
        uint32 sessionStartTime = 0;
        uint32 lastSeenTime = 0;
        uint32 totalPlayTime = 0;
        
        // Add custom player data here
    }};
    
    // Private methods
    bool CheckDependencies();
    void RegisterChatCommands();
    void UnregisterChatCommands();
    void UpdateStatistics();
    void SaveStatistics();
    void CleanupPlayerData();
    
    // Member variables
    bool _enabled;
    bool _debugMode;
    ModuleConfig _config;
    
    // Player data management
    std::unordered_map<ObjectGuid, PlayerData> _playerData;
    mutable std::mutex _playerDataMutex;
    
    // Statistics
    uint32 _totalLogins;
    uint32 _totalLevelUps;
    uint32 _lastStatsUpdate;
    uint32 _lastConfigCheck;
    
    // Event handler
    std::unique_ptr<PluginEventHandler> _eventHandler;
    
    // Singleton instance
    static {class_name}* _instance;
}};

// Registration macro
REGISTER_PLUGIN({class_name});

#endif // {module_name.upper()}_MODULE_H
'''
    
    header_file = module_dir / "src" / f"{class_name}.h"
    with open(header_file, 'w', encoding='utf-8') as f:
        f.write(header_content)
    
    print(f"Created: {header_file}")
    return header_file

def create_source_file(module_dir, module_name, author):
    """Create the main module source file"""
    class_name = f"{module_name}Module"
    source_content = f'''/*
 * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "{class_name}.h"
#include "Player.h"
#include "Chat.h"
#include "World.h"
#include "WorldSession.h"
#include "Config.h"
#include "Log.h"
#include "GameTime.h"

// Singleton instance
{class_name}* {class_name}::_instance = nullptr;

{class_name}::{class_name}()
    : _enabled(false)
    , _debugMode(false)
    , _totalLogins(0)
    , _totalLevelUps(0)
    , _lastStatsUpdate(0)
    , _lastConfigCheck(0)
{{
    _instance = this;
}}

{class_name}::~{class_name}()
{{
    Shutdown();
    _instance = nullptr;
}}

{class_name}* {class_name}::GetInstance()
{{
    return _instance;
}}

bool {class_name}::Initialize()
{{
    TC_LOG_INFO("modules", "Initializing {module_name} Module...");
    
    // Load configuration
    if (!LoadConfiguration())
    {{
        TC_LOG_ERROR("modules", "Failed to load {module_name} Module configuration");
        return false;
    }}
    
    // Check dependencies
    if (!CheckDependencies())
    {{
        TC_LOG_ERROR("modules", "{module_name} Module dependency check failed");
        return false;
    }}
    
    // Register chat commands
    RegisterChatCommands();
    
    // Initialize statistics
    _totalLogins = 0;
    _totalLevelUps = 0;
    _lastStatsUpdate = GameTime::GetGameTime();
    _lastConfigCheck = GameTime::GetGameTime();
    
    _enabled = true;
    
    TC_LOG_INFO("modules", "{module_name} Module initialized successfully");
    return true;
}}

void {class_name}::Shutdown()
{{
    if (!_enabled)
        return;
        
    TC_LOG_INFO("modules", "Shutting down {module_name} Module...");
    
    // Save statistics
    SaveStatistics();
    
    // Clear player data
    {{
        std::lock_guard<std::mutex> lock(_playerDataMutex);
        _playerData.clear();
    }}
    
    // Unregister chat commands
    UnregisterChatCommands();
    
    _enabled = false;
    
    TC_LOG_INFO("modules", "{module_name} Module shut down successfully");
}}

void {class_name}::Update(uint32 diff)
{{
    if (!_enabled)
        return;
        
    uint32 currentTime = GameTime::GetGameTime();
    
    // Update statistics periodically
    if (currentTime - _lastStatsUpdate >= 30) // Every 30 seconds
    {{
        UpdateStatistics();
        _lastStatsUpdate = currentTime;
    }}
    
    // Check for configuration changes
    if (currentTime - _lastConfigCheck >= 60) // Every minute
    {{
        // Implement hot reload if needed
        _lastConfigCheck = currentTime;
    }}
    
    // Clean up offline player data
    CleanupPlayerData();
}}

bool {class_name}::LoadConfiguration()
{{
    try
    {{
        _config.enabled = sConfigMgr->GetBoolDefault("{module_name}.Enabled", true);
        _config.debugMode = sConfigMgr->GetBoolDefault("{module_name}.DebugMode", false);
        
        // Load your configuration options here
        _config.welcomeMessage = sConfigMgr->GetStringDefault("{module_name}.WelcomeMessage", "Welcome to the server!");
        _config.enableWelcome = sConfigMgr->GetBoolDefault("{module_name}.EnableWelcome", true);
        _config.welcomeDelay = sConfigMgr->GetIntDefault("{module_name}.WelcomeDelay", 5);
        
        _config.enablePlayerTracking = sConfigMgr->GetBoolDefault("{module_name}.EnablePlayerTracking", true);
        _config.enableChatLogging = sConfigMgr->GetBoolDefault("{module_name}.EnableChatLogging", false);
        _config.enableStatistics = sConfigMgr->GetBoolDefault("{module_name}.EnableStatistics", true);
        
        if (_config.debugMode)
        {{
            TC_LOG_DEBUG("modules", "{module_name} Module configuration loaded successfully");
        }}
        
        return true;
    }}
    catch (const std::exception& e)
    {{
        TC_LOG_ERROR("modules", "Failed to load {module_name} Module configuration: {{}}", e.what());
        return false;
    }}
}}

bool {class_name}::ReloadConfiguration()
{{
    TC_LOG_INFO("modules", "Reloading {module_name} Module configuration...");
    return LoadConfiguration();
}}

bool {class_name}::CheckDependencies()
{{
    // Check if required systems are available
    if (!sWorld)
    {{
        TC_LOG_ERROR("modules", "World system not available");
        return false;
    }}
    
    if (!sConfigMgr)
    {{
        TC_LOG_ERROR("modules", "Configuration manager not available");
        return false;
    }}
    
    return true;
}}

void {class_name}::RegisterChatCommands()
{{
    // Register your chat commands here
    if (_config.debugMode)
    {{
        TC_LOG_DEBUG("modules", "{module_name} Module chat commands registered");
    }}
}}

void {class_name}::UnregisterChatCommands()
{{
    // Unregister chat commands
    if (_config.debugMode)
    {{
        TC_LOG_DEBUG("modules", "{module_name} Module chat commands unregistered");
    }}
}}

void {class_name}::OnPlayerLogin(Player* player)
{{
    if (!player || !_config.enablePlayerTracking)
        return;
        
    ObjectGuid guid = player->GetGUID();
    
    {{
        std::lock_guard<std::mutex> lock(_playerDataMutex);
        
        auto& data = _playerData[guid];
        data.loginCount++;
        data.sessionStartTime = GameTime::GetGameTime();
        data.lastSeenTime = GameTime::GetGameTime();
        
        _totalLogins++;
    }}
    
    // Send welcome message
    if (_config.enableWelcome)
    {{
        player->GetScheduler().Schedule(Milliseconds(_config.welcomeDelay * 1000), [this, player](TaskContext /*context*/)
        {{
            if (player && player->IsInWorld())
            {{
                ChatHandler(player->GetSession()).SendSysMessage(_config.welcomeMessage.c_str());
            }}
        }});
    }}
    
    if (_config.debugMode)
    {{
        TC_LOG_DEBUG("modules", "Player {{}} logged in, total logins: {{}}", 
                    player->GetName(), _totalLogins);
    }}
}}

void {class_name}::OnPlayerLogout(Player* player)
{{
    if (!player || !_config.enablePlayerTracking)
        return;
        
    ObjectGuid guid = player->GetGUID();
    
    {{
        std::lock_guard<std::mutex> lock(_playerDataMutex);
        
        auto it = _playerData.find(guid);
        if (it != _playerData.end())
        {{
            it->second.lastSeenTime = GameTime::GetGameTime();
            it->second.totalPlayTime += GameTime::GetGameTime() - it->second.sessionStartTime;
        }}
    }}
    
    if (_config.debugMode)
    {{
        TC_LOG_DEBUG("modules", "Player {{}} logged out", player->GetName());
    }}
}}

void {class_name}::OnPlayerLevelChanged(Player* player, uint8 oldLevel)
{{
    if (!player)
        return;
        
    uint8 newLevel = player->getLevel();
    
    {{
        std::lock_guard<std::mutex> lock(_playerDataMutex);
        _totalLevelUps++;
    }}
    
    if (_config.debugMode)
    {{
        TC_LOG_DEBUG("modules", "Player {{}} leveled from {{}} to {{}}, total level ups: {{}}", 
                    player->GetName(), oldLevel, newLevel, _totalLevelUps);
    }}
}}

void {class_name}::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg)
{{
    if (!player || !_config.enableChatLogging)
        return;
        
    if (_config.debugMode)
    {{
        TC_LOG_DEBUG("modules", "Player {{}} chat: {{}}", player->GetName(), msg);
    }}
}}

bool {class_name}::HandleInfoCommand(ChatHandler* handler, char const* args)
{{
    // Implement your info command here
    handler->SendSysMessage("{module_name} Module Information");
    handler->SendSysMessage("Version: 1.0.0");
    handler->SendSysMessage("Author: {author}");
    return true;
}}

bool {class_name}::HandleConfigCommand(ChatHandler* handler, char const* args)
{{
    // Implement your config command here
    if (ReloadConfiguration())
    {{
        handler->SendSysMessage("{module_name} configuration reloaded successfully.");
    }}
    else
    {{
        handler->SendSysMessage("Failed to reload {module_name} configuration.");
    }}
    return true;
}}

void {class_name}::UpdateStatistics()
{{
    if (!_config.enableStatistics)
        return;
        
    // Update your statistics here
}}

void {class_name}::SaveStatistics()
{{
    if (!_config.enableStatistics)
        return;
        
    // Save statistics to file or database
}}

void {class_name}::CleanupPlayerData()
{{
    if (!_config.enablePlayerTracking)
        return;
        
    // Clean up offline player data periodically
    std::lock_guard<std::mutex> lock(_playerDataMutex);
    
    uint32 currentTime = GameTime::GetGameTime();
    auto it = _playerData.begin();
    
    while (it != _playerData.end())
    {{
        // Remove data for players offline for more than 1 hour
        if (currentTime - it->second.lastSeenTime > 3600)
        {{
            it = _playerData.erase(it);
        }}
        else
        {{
            ++it;
        }}
    }}
}}

// Plugin registration
REGISTER_PLUGIN({class_name});
'''
    
    source_file = module_dir / "src" / f"{class_name}.cpp"
    with open(source_file, 'w', encoding='utf-8') as f:
        f.write(source_content)
    
    print(f"Created: {source_file}")
    return source_file

def create_config_file(module_dir, module_name):
    """Create the configuration file for the module"""
    config_content = f'''#
# {module_name} Module Configuration
# Generated by TrinityCore Module Creator
#

###################################################################################################
# {module_name.upper()} MODULE SETTINGS
###################################################################################################

#
# {module_name}.Enabled
#     Description: Enable/disable the {module_name} module
#     Default:     1 (enabled)
#

{module_name}.Enabled = 1

#
# {module_name}.DebugMode
#     Description: Enable debug logging for the module
#     Default:     0 (disabled)
#

{module_name}.DebugMode = 0

#
# {module_name}.WelcomeMessage
#     Description: Welcome message to display to players
#     Default:     "Welcome to the server!"
#

{module_name}.WelcomeMessage = "Welcome to our TrinityCore server!"

#
# {module_name}.EnableWelcome
#     Description: Enable/disable welcome message
#     Default:     1 (enabled)
#

{module_name}.EnableWelcome = 1

#
# {module_name}.WelcomeDelay
#     Description: Delay in seconds before showing welcome message
#     Default:     5
#

{module_name}.WelcomeDelay = 5

#
# {module_name}.EnablePlayerTracking
#     Description: Enable player login/logout tracking
#     Default:     1 (enabled)
#

{module_name}.EnablePlayerTracking = 1

#
# {module_name}.EnableChatLogging
#     Description: Enable chat message logging
#     Default:     0 (disabled)
#

{module_name}.EnableChatLogging = 0

#
# {module_name}.EnableStatistics
#     Description: Enable statistics collection
#     Default:     1 (enabled)
#

{module_name}.EnableStatistics = 1
'''
    
    config_file = module_dir / "conf" / f"{module_name}.conf"
    with open(config_file, 'w', encoding='utf-8') as f:
        f.write(config_content)
    
    print(f"Created: {config_file}")
    return config_file

def create_readme_file(module_dir, module_name, author, description):
    """Create the README.md file for the module"""
    readme_content = f'''# {module_name} Module

{description}

## Overview

This module provides [describe your module functionality here].

## Features

- Player event handling
- Configuration management
- Chat commands
- Statistics collection
- Hot configuration reload

## Installation

1. Copy the module to your `modules/mod-{module_name.lower()}/` directory
2. Add the module to your CMake build
3. Configure the module settings in `{module_name}.conf`
4. Build and restart your server

## Configuration

The module can be configured through the `{module_name}.conf` file:

```ini
# Enable/disable the module
{module_name}.Enabled = 1

# Enable debug logging
{module_name}.DebugMode = 0

# Welcome message settings
{module_name}.WelcomeMessage = "Welcome to our server!"
{module_name}.EnableWelcome = 1
{module_name}.WelcomeDelay = 5

# Feature toggles
{module_name}.EnablePlayerTracking = 1
{module_name}.EnableChatLogging = 0
{module_name}.EnableStatistics = 1
```

## Chat Commands

- `.{module_name.lower()} info` - Display module information
- `.{module_name.lower()} config` - Reload module configuration

## API

### Events

The module handles the following events:

- `OnPlayerLogin` - Called when a player logs in
- `OnPlayerLogout` - Called when a player logs out
- `OnPlayerLevelChanged` - Called when a player levels up
- `OnPlayerChat` - Called when a player sends a chat message

### Configuration

Configuration can be reloaded at runtime using:

```cpp
{module_name}Module::GetInstance()->ReloadConfiguration();
```

## Development

### Building

```bash
mkdir build
cd build
cmake ..
make {module_name}
```

### Testing

```bash
make test_{module_name}
./test_{module_name}
```

### Debugging

Enable debug mode in the configuration:

```ini
{module_name}.DebugMode = 1
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests if applicable
5. Submit a pull request

## License

This module is licensed under the GPL-2.0 License. See the LICENSE file for details.

## Author

**{author}**

## Changelog

### Version 1.0.0
- Initial module creation
- Basic player event handling
- Configuration management
- Chat command support
'''
    
    readme_file = module_dir / "README.md"
    with open(readme_file, 'w', encoding='utf-8') as f:
        f.write(readme_content)
    
    print(f"Created: {readme_file}")
    return readme_file

def main():
    parser = argparse.ArgumentParser(
        description='Create a new TrinityCore module template',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  python create_module.py MyModule
  python create_module.py AwesomeFeature --author "John Doe" --description "An awesome feature"
  python create_module.py CustomSystem --version "2.0.0" --core-version "3.3.5a"
        '''
    )
    
    parser.add_argument('module_name', help='Name of the module to create')
    parser.add_argument('--author', default='Unknown', help='Author name (default: Unknown)')
    parser.add_argument('--description', help='Module description')
    parser.add_argument('--version', default='1.0.0', help='Module version (default: 1.0.0)')
    parser.add_argument('--core-version', default='3.3.5', help='TrinityCore version (default: 3.3.5)')
    parser.add_argument('--output-dir', help='Output directory (default: current directory)')
    
    args = parser.parse_args()
    
    # Validate module name
    module_name = args.module_name.strip()
    if not module_name:
        print("Error: Module name cannot be empty")
        return 1
    
    if not module_name.replace('_', '').replace('-', '').isalnum():
        print("Error: Module name can only contain letters, numbers, hyphens, and underscores")
        return 1
    
    # Set default description
    description = args.description or f"A custom module for TrinityCore: {module_name}"
    
    # Determine output directory
    if args.output_dir:
        base_dir = Path(args.output_dir)
    else:
        base_dir = Path.cwd()
    
    try:
        print(f"Creating module: {module_name}")
        print(f"Author: {args.author}")
        print(f"Description: {description}")
        print(f"Version: {args.version}")
        print(f"Core Version: {args.core_version}")
        print(f"Output Directory: {base_dir}")
        print()
        
        # Create module structure
        module_dir = create_module_structure(module_name, base_dir)
        
        # Create module files
        create_module_json(module_dir, module_name, args.author, description, args.version, args.core_version)
        create_cmake_file(module_dir, module_name)
        create_header_file(module_dir, module_name, args.author)
        create_source_file(module_dir, module_name, args.author)
        create_config_file(module_dir, module_name)
        create_readme_file(module_dir, module_name, args.author, description)
        
        print()
        print(f"Module '{module_name}' created successfully!")
        print(f"Location: {module_dir}")
        print()
        print("Next steps:")
        print("1. Customize the module code in the src/ directory")
        print("2. Update the configuration in conf/ directory")
        print("3. Add the module to your CMake build")
        print("4. Build and test your module")
        print()
        print("Happy coding!")
        
        return 0
        
    except FileExistsError as e:
        print(f"Error: {e}")
        return 1
    except Exception as e:
        print(f"Error creating module: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())